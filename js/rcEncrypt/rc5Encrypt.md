# Реализация шифрования RC5

Этот скрипт представляет собой мою реализацию алгоритма шифрования **RC5**. RC5 — это блочный шифр с адаптивными параметрами, такими как длина слова, число раундов и длина ключа. В данном случае я использую длину слова 32 бита, 12 раундов шифрования и 128-битный ключ.

---

## Основные этапы работы скрипта

### 1. **Константы RC5**

В начале определяются константы `P` и `Q`, которые зависят от длины слова (16, 32 или 64 бита):

```javascript
const RC5_CONST = {
    16: [0xb7e1n, 0x9e37n],
    32: [0xb7e15163n, 0x9e3779b9n],
    64: [0xb7e151628aed2a6bn, 0x9e3779b97f4a7c15n],
};
```

Эти константы используются для расширения ключа.

---

### 2. **Класс `RC5Cipher`**

Я разработал класс `RC5Cipher`, который инкапсулирует весь функционал RC5. Его методы выполняют шифрование и расшифровку, а также предварительную обработку ключа.

#### Конструктор

При инициализации объекта задаются параметры:

-   `w` — длина слова (32 бита).
-   `r` — количество раундов (12).
-   `key` — ключ шифрования.

#### Методы класса

1. **`_keyAlign`** — выравнивает ключ до длины, кратной размеру слова.
2. **`_keyExtend`** — создаёт массив `S` на основе констант `P` и `Q`.
3. **`_mix`** — выполняет перемешивание ключевых слов и массива `S`.

4. **`encryptBlock` и `decryptBlock`** — методы для шифрования и расшифровки одного блока данных. Они используют побитовые операции, такие как сложение, вычитание и циклические сдвиги.

---

### 3. **Работа с сообщением**

Далее я добавил вспомогательные функции для работы с данными:

-   **`stringToByteArray`**: преобразует строку в массив байтов.
-   **`byteArrayToBigInt`**: преобразует массив байтов в число `BigInt`.
-   **`bigIntToByteArray`**: выполняет обратное преобразование из `BigInt` в массив байтов.
-   **`byteArrayToString`**: возвращает строку из массива байтов.
-   **`byteArrayToBase64`**: преобразует массив байтов в строку Base64.

---

### 4. **Шифрование**

Сообщение разбивается на блоки (размер блока — 8 байтов). Если длина сообщения не кратна размеру блока, выполняется дополнение нулями:

```javascript
const blockSize = 8;
const paddedLength = Math.ceil(byteArrayMessage.length / blockSize) * blockSize;
const paddedMessage = new Uint8Array(paddedLength);
paddedMessage.set(byteArrayMessage);
for (let i = byteArrayMessage.length; i < paddedLength; i++) {
    paddedMessage[i] = 0;
}
```

Каждый блок шифруется с использованием метода `encryptBlock` и сохраняется в массиве `encryptedBlocks`. После этого данные кодируются в формат Base64 для удобного хранения:

```javascript
const encryptedBase64 = byteArrayToBase64(encryptedBlocks);
```

---

### 5. **Расшифровка**

Процесс расшифровки начинается с декодирования зашифрованных данных. Каждый блок обрабатывается с помощью метода `decryptBlock`, а затем объединяется обратно в строку:

```javascript
const decryptedBlocks = [];
for (let i = 0; i < encryptedBlocks.length; i += blockSize) {
    const block = encryptedBlocks.slice(i, i + blockSize);
    const decryptedBlock = rc5.decryptBlock(byteArrayToBigInt(block));
    decryptedBlocks.push(decryptedBlock);
}
```

Завершающим этапом является удаление лишних нулей, добавленных при дополнении.

---

### 6. **Вывод результатов**

Результаты выводятся в консоль:

-   Исходный ключ.
-   Зашифрованное сообщение в формате Base64.
-   Расшифрованное сообщение.

```javascript
console.log(`Key: ${key}`);
console.log(`Encrypted (Base64): ${encryptedBase64}`);
console.log(`Decrypted: ${decryptedMessage}`);
```

---

## Пример использования

Для демонстрации работы шифра я задал ключ `123456789` и сообщение `"Hello, World!"`. После шифрования сообщение преобразуется в Base64, а затем успешно расшифровывается.

---
